\documentclass{article}
\input{linear}
% \usepackage[tmargin=0.15in, bmargin=0.15in]{geometry}
\input{prooftree}
% \usepackage{stmaryrd}
% \usepackage{latexsym}
% \usepackage{amsmath}

% \usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\def\aret{\hookleftarrow}
\def\L{\texttt{(}}
\def\R{\texttt{)}}
\def\Lb{\texttt{[}}
\def\Rb{\texttt{]}}

\def\make{\rightsquigarrow}
\def\cn{{:}}
\def\tr{{\triangleright}}
\def\bu{\bullet}
\def\rtype{\mathsf{type}}
\def\rkind{\mathsf{kind}}

\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}
\title{A Concatenative Typechecker for LF}
\author{Jason Reed}

% no extra space after colon
\AddToHook{cmd/ttfamily/after}{\frenchspacing}

\begin{document}
\maketitle
\section{Introduction}

\section{deBruijn Language}
\[
\begin{tabular}{lc@{$\quad::=\quad$}l}
 Signature& $\Sigma$&$\cdot  \celse \Sigma, c : A : Q$\\
 Context& $\Gamma$&$\cdot \celse \Gamma, x : A : Q$\\
 Stack& $\Delta$&$\cdot  \celse \Gamma, M : A$\\
 Program& $P$&$\cdot  \celse P, \iota$\\
 Instruction& $\iota$&$c \celse \underline n \celse \Pi \celse \lambda \celse \tr \celse \bu_c \celse \rtype$\\
 %% Compiled Program& $Q$&$\cdot  \celse Q, \theta$\\
 %% Compiled
 %% Instruction& $\theta$&\\
\end{tabular} \]

Every instruction can be interpreted in two ways. The ``interactive'' interpretation is:

\[
{\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ll}
\hline
$a$&Pop arguments $S$ off $\Delta$, typecheck them, push $a \cdot S : \rtype$\\
$c$&Pop arguments $S$ off $\Delta$, typecheck them, push $c\cdot S : B$\\
$\underline n$&Pop arguments $S$ off $\Delta$, typecheck them, push $\underline n \cdot S : B$\\
$\Pi$&Pop $x:A$ from $\Gamma$, pop $B:\rtype$ from $\Delta$, push $\Pi x\cn A . B  : \rtype$ to $\Delta$\\
$\Pi$&Pop $x:A$ from $\Gamma$, pop $K:\rkind$ from $\Delta$, push $\Pi x\cn A . K : \rkind$ to $\Delta$\\
$\lambda$&Pop $x:A$ from $\Gamma$, pop $M:B$ from $\Delta$, push $\lambda x\cn A . B$ to $\Delta$\\
$\bu_c$&Pop $A:\rtype$ from $\Delta$, push $c : A$ to $\Sigma$\\
$\bu_a$&Pop $K:\rkind$ from $\Delta$, push $a : K$ to $\Sigma$\\
$\rtype$&Push $\rtype : \rkind$ to $\Delta$\\
\hline
\end{tabular}
}
\]

The ``compiled'' interpretation is:
\[
{\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ll}
\hline
$a$&run $a$ in compiled mode\\
$c$&run $c$ in compiled mode\\
$\underline n$&run $\underline n$ in compiled mode\\
$\Pi$&Pop $M:A$,$A':\rtype$ from $\Delta$, check $A = A'$. \\
$\lambda$&?\\
$\bu_c$&Pop $A:\rtype$ from $\Delta$, push $c : A$ to $\Sigma$\\
$\bu_a$&Pop $K:\rkind$ from $\Delta$, push $a : K$ to $\Sigma$\\
$\rtype$&Push $\rtype : \rkind$ to $\Delta$\\
\hline
\end{tabular}
}
\]

\section{Named Language}
\[
\begin{tabular}{lc@{$\quad::=\quad$}l}
 Signature& $\Sigma$&$\cdot  \celse \Sigma, c : A$\\
 Context& $\Gamma$&$\cdot \celse \Gamma, x : A$\\
 Stack& $\Delta$&$\cdot  \celse \Gamma, M : A$\\
 Program& $P$&$\cdot  \celse P, \iota$\\
 Instruction& $\iota$&$c \celse x \celse \Pi \celse \lambda \celse \tr_x \celse \bu_c \celse \rtype$\\
\end{tabular} \]

We aim to define the judgment
 \[(\Sigma/ \Gamma/ \Delta) + \iota = (\Sigma'/ \Gamma'/ \Delta')\]
by the rules
\[
\begin{prooftree}
\justifies
(\Sigma/ \Gamma/ \Delta) + \rtype = (\Sigma, \rtype: \rkind/ \Gamma/ \Delta)
\end{prooftree}
\]

\[
\begin{prooftree}
c : o \in \Sigma
\justifies
(\Sigma/ \Gamma/ \Delta) + c = (\Sigma / \Gamma/ \Delta, c : o)
\end{prooftree}
\]

\[
\begin{prooftree}
x : o \in \Gamma
\justifies
(\Sigma/ \Gamma/ \Delta) + x = (\Sigma / \Gamma/ \Delta, x : o)
\end{prooftree}
\]

\[
\begin{prooftree}
\justifies
(\Sigma/ \Gamma, x : A/ \Delta, B : \rtype) + \Pi = (\Sigma / \Gamma/ \Delta, (\Pi x \cn A . B) : \rtype)
\end{prooftree}
\]

\[
\begin{prooftree}
\justifies
(\Sigma/ \Gamma, x : A/ \Delta, M : B) + \lambda = (\Sigma / \Gamma/ \Delta, (\lambda x \cn A . M) : (\Pi x \cn A . B))
\end{prooftree}
\]

\[
\begin{prooftree}
\justifies
(\Sigma/ \Gamma/ \Delta, A : \rtype) + \tr_x = (\Sigma / \Gamma, x : A/ \Delta)
\end{prooftree}
\]

\[
\begin{prooftree}
\justifies
(\Sigma/ \Gamma/ \Delta, A : \rtype) + \bu_c = (\Sigma, c : A / \Gamma/ \Delta)
\end{prooftree}
\]

%% o : type.
%% k : o.
%% l : o.
%% s : o -> o.
%% a : o -> type.
%% b : o -> o -> type.
%% bt : b k (s l).
%% bt2 : {x:o} b x x.
%% c : (o -> o) -> type.
%% d : {x:o} a (s x) -> type.
%% e : {x:o} {y:o} b y (s x) -> type.
%% et: e l k bt.
%% et2 : e k (s k) (bt2 (s k)).
%% ct : c ([x] s (s x)).
%% h : ((o -> o) -> o) -> type.
%% ht : h ([f] f (s k)).

\subsection{Examples}
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
term & representation \\
\hline
$o : \rtype$ & $\mathtt{type\ \bu_o}$\\
$k : o$ & $\mathtt{o\ \bu_k}$\\
$\ell : o$ & $\mathtt{o\ \bu_\ell}$\\
$s : o \to o$ & $\mathtt{o\ \tr\ o\ \Pi\ \bu_s}$\\
$a : o \to \rtype$ & $\mathtt{o\ \tr\ type\ \Pi\ \bu_a}$\\
$b : o \to o \to \rtype$ & $\mathtt{o\ \tr\ o\ \tr\ type\ \Pi\ \Pi\ \bu_b}$\\
$bt : b\ k\ (s\ \ell)$ & $\mathtt{\ell\ s\ k \ b\ \bu_{bt}}$\\
$bt2 : \{x : o\}\ b\ x\ x$ & $\mathtt{o\ \tr_x\ x\ x\ b\ \Pi\ \bu_{bt2}}$\\
$c : (o \to o) \to \rtype$ & $\mathtt{o\ \tr\ o\ \Pi\ \tr\ type\ \Pi\ \bu_c}$\\
$d : \{x : o\}\ a\ (s\ x) \to \rtype$ & $\mathtt{o\ \tr_x\ x\ s\ a\ \tr\ \Pi\ \Pi\ \bu_d }$\\
$e : \{x : o\}\{y : o\}\ b\ y\ (s\ x) \to \rtype$ & $\mathtt{o\ \tr_x\ o\ \tr_y\ x\ s\ y\ b\ \tr\ \Pi\ \Pi\ \Pi\ \bu_e }$\\
$et : e\ \ell\ k\ bt$ & $\mathtt{bt\ k\ \ell\ e\ \bu_{et} }$\\
$et2 : e\ k\ (s\ k)\ (bt2\ (s\ k))$ & $\mathtt{k\ s\ bt2\ k\ s\ k\ e\ \bu_{et2}}$\\
$ct : c\ (\lambda x . s\ (s\ x))$ & $\mathtt{o\ \tr_x\ s\ s\ \lambda\ c\  \bu_{ct}}$\\
$h : ((o \to o) \to o) \to \rtype$ & $\mathtt{o\ \tr\ o\ \Pi\ \tr\ o\ \Pi\ \tr\ type\ \bu_h}$\\
$ht : h\ (\lambda (f\cn o\to o) . f\ (s\ k))$ & $\mathtt{o\ \tr\ o\ \Pi\ \tr_f\ k\ s\ f\ \lambda\ h\  \bu_{ht}}$\\
\hline
\end{tabular}\]
}

Why don't I do something like represent
$b : o \to o \to \rtype$ as
\[\mathtt{ type\ o\ \tr\ \Pi\ o\ \tr\ \Pi\ \bu_b}\]
instead, and perhaps even fuse the $\tr$ and $\Pi$ into a single operation?
Because although this works in this nondependent case, I might need to use the $\Pi$-bound variables
in the body of the $\Pi$, so they must come first.

\section{Why not $\Pi$}

I think I want `execution' of a constant to reuse the same program
that was used to build up its declaration. For this to work, I need to
know which $\tr$ are part of the main spine of that constant, and
which are nested in its arguments. When I have $\Pi$s belatedly telling me how to build up the spine,
this information is buried. I think I might want to have explicit $\L$ and $\R$ instructions giving $\Pi$ scopes
and I guess $\Lb$ and $\Rb$ for $\lambda$ scopes after all. So let's try:
\subsection{Examples}
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
term & representation \\
\hline
$o : \rtype$ & $\mathtt{\L\ type\ \R\ \bu_o}$\\
$k : o$ & $\mathtt{\L\ o\ \R\ \bu_k}$\\
$\ell : o$ & $\mathtt{\L\ o\ \R\ \bu_\ell}$\\
$s : o \to o$ & $\mathtt{\L\ o\ \tr\ o\ \R\ \bu_s}$\\
$a : o \to \rtype$ & $\mathtt{\L\ o\ \tr\ type\ \R\ \bu_a}$\\
$b : o \to o \to \rtype$ & $\mathtt{\L\ o\ \tr\ o\ \tr\ type\ \R\ \bu_b}$\\
$bt : b\ k\ (s\ \ell)$ & $\mathtt{\L\ \ell\ s\ k \ b\ \R\ \bu_{bt}}$\\
$bt2 : \{x : o\}\ b\ x\ x$ & $\mathtt{\L\ o\ \tr_x\ x\ x\ b\ \R\ \bu_{bt2}}$\\
$c : (o \to o) \to \rtype$ & $\mathtt{\L\ \L\ o\ \tr\ o\ \R\ \tr\ type\ \R\ \bu_c}$\\
$d : \{x : o\}\ a\ (s\ x) \to \rtype$ & $\mathtt{\L\ o\ \tr_x\ x\ s\ a\ \tr\ type\ \R\ \bu_d }$\\
$e : \{x : o\}\{y : o\}\ b\ y\ (s\ x) \to \rtype$ & $\mathtt{\L\ o\ \tr_x\ o\ \tr_y\ x\ s\ y\ b\ \tr\ type\ \R\ \bu_e }$\\
$et : e\ \ell\ k\ bt$ & $\mathtt{\L\ bt\ k\ \ell\ e\ \R\ \bu_{et} }$\\
$et2 : e\ k\ (s\ k)\ (bt2\ (s\ k))$ & $\mathtt{\L\ k\ s\ bt2\ k\ s\ k\ e\ \R\ \bu_{et2}}$\\
$ct : c\ (\lambda x . s\ (s\ x))$ & $\mathtt{\L\ \Lb\ o\ \tr_x\ x\ s\ s\ \Rb\ c\  \R\ \bu_{ct}}$\\
$h : ((o \to o) \to o) \to \rtype$ & $\mathtt{\L\ \L\ \L\ o\ \tr\ o\ \R\ \tr\ o\ \R\ \tr\ type\ \R\ \bu_h}$\\
$ht : h\ (\lambda (f\cn o\to o) . f\ (s\ k))$ & $\mathtt{\L\ \Lb\ \L\ o\ \tr\ o\ \R\ \tr_f\ k\ s\ f\ \Rb \ h\  \R\ \bu_{ht}}$\\
\hline
\end{tabular}\]
}

\[
{\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ll}
\hline
$\mathtt c$&Set $\rho =\texttt{tt}$, run program for $c$\\
$\L[\rho = \texttt{ff}]$&Push $\gamma = ()$ to $\Gamma$\\
$\L[\rho = \texttt{tt}]$&Push $\theta = \cdot$ to $\Gamma$, set $\rho = \texttt{ff}$\\
$\R$&Pop $A:\rtype$ from $\Delta$, $(\gamma)_\rho$ from $\Gamma$, push $\Pi \gamma . A$ to $\Delta$\\
$\tr_x[(\Gamma, \gamma)]$&Pop $A: \rtype$ from $\Delta$, push $x:A$ to $\gamma$\\
$\bu_c[\rho = \texttt{ff}]$&Pop $A:\rtype$ from $\Delta$, push $c : A$ to $\Sigma$\\
$\tr_x[(\Gamma, \theta)]$&Pop $M:A, A': \rtype$ from $\Delta$, check $A = A'$, push $M/x:A$ to $\theta$\\
$\bu_c[\rho = \texttt{tt}]$&Pop $S$ from $\Gamma$, push $c\cdot S : A$ to $\Delta$\\
$\rtype$&Push $\rtype : \rkind$ to $\Delta$\\
\hline
\end{tabular}
}
\]

\section{Taking Stock}
I have a vague idea of what I want constants of various types to {\em
  do}, even if capturing/compiling the program to do that seems rather
tricky right now. I think there may still be some corner cases around
deBruijn indices or substitutions or something, so let me work out
some more examples. My current preferred set of instructions for just forming expressions is something like:
\[
{\renewcommand{\arraystretch}{1.2}
\begin{tabular}{ll}
\hline
$\mathtt c$&Push empty substitution to metastack, run $c$'s program\\
$\rtype$&Push $\rtype : \rkind$ to $\Delta$\\
$\R$&Pop $A:\rtype$ from $\Delta$, $(\gamma)_\rho$ from $\Gamma$, push $\Pi \gamma . A$ to $\Delta$\\
$\tr$&Pop $A: \rtype$, Pop $M : A$, append $[M/x]^\nu$ to current stack  \\
$:$&Set $\nu$ to next token \\
$\aret$&Pop $A : \rtype$, $S$ from the metastack, push $\nu \cdot S : A$\\
$n$&Copy $n^{th}$ item from current substitution onto stack\\
\hline
\end{tabular}
}
\]

{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
term & program \\
\hline
$o : \rtype$ &\texttt{type {:} o $\aret$}\\
$k : o$ &\texttt{o : k $\aret$}\\
$\ell : o$ &\texttt{o : $\ell$ $\aret$}\\
$s : o \to o$&\texttt{o $\tr$ o : s $\aret$} \\
$a : o \to \rtype$ &\texttt{o $\tr$ type : a $\aret$}\\
$b : o \to o \to \rtype$ &\texttt{o $\tr$ o $\tr$ type : b $\aret$}\\
$d : \{x : o\} \to a\ x \to \rtype$ &\texttt{o $\tr$ 1 a $\tr$ type : d $\aret$}\\
$bt0 : b\ k\ (s\ \ell)$ &\texttt{$\ell$ s k b : bt0 $\aret$}\\
% $bt2 : \{x : o\}\ b\ x\ x$ & \texttt{o : x $\tr$ x x b : bt2 $\aret$}\\
$bt2 : \{x : o\}\ b\ x\ x$  & \texttt{o $\tr$ 1 1 b : bt2 $\aret$}\\
$bt : \{x : o\}\{y : o\}\ b\ x\ y$  & \\
$c : (o \to o) \to \rtype$ &\\
$c2 : \{x : o\}\  (\{y : o\}\ b\ x\ y) \to \rtype$ &\\
$g : \{x : o\}\ c2\ x\ (\lambda y . bt\ x\ y)$  & \\

$e : \{x : o\}\{y : o\}\ b\ y\ (s\ x) \to \rtype$ &\\
$f : \{x : o\}\ a\ (s\ x) \to \rtype$ &\\
$et : e\ \ell\ k\ bt$ &\\
$et2 : e\ k\ (s\ k)\ (bt2\ (s\ k))$ &\\
$ct : c\ (\lambda x . s\ (s\ x))$ &\\
$h : ((o \to o) \to o) \to \rtype$ &\\
$ht : h\ (\lambda (f\cn o\to o) . f\ (s\ k))$ &\\
\hline
\end{tabular}\]
}

The effect of running \texttt{o} is putting $o : \rtype$ on the stack.

\section{Why Running Existing Code Might Not Work}

One of the earlier prototype versions (at commit \texttt{9f0a16d},
e.g.) had a notion of program counter that just iterated over the
original token stream; when you called a constant, it jumped {\em
  back} to earlier tokens. I worry this strategy might not work for
variables. When a variable is applied as a head to some spine of
arguments sitting on the stack, we must run its `type-checking
program'. I'd like to think that what its program really is is the
result of substituting variables that occur in it.

Having said that, here's an alternative that might save the idea:
while executing code in the token stream, it nonetheless has knowledge
of {\em from where} (living in some other meta-context substitution
somewhere, maybe?) it's supposed to grab the values corresponding to
deBruijn indices.

In either case, I'd like a decisive example that exercises the
relevant situation. I know I want some kind of constant $z$ with a kind like
\[ w : \{x : A\}\{y : B\} \{z : C\}\, \rtype \]
where $x$ occurs in $B$, (so that the type $B$ whose structure is $y$'s `program' actually gets modified
depending on what $x:A$ is) and $y$ occurs in $C$ (so that $y$ is really used as a head).

So what's a minimal signature that meets these requirements?
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l}
\hline
$o : \rtype$ \\
$a : o \to \rtype$ \\
$b : \{x : o\} \, a\ x   \to \rtype$ \\
$w : \{x : o\}\{y : a\ x\} \{z : b\ x\ y\} \, \rtype$ \\
\hline
\end{tabular}\]
}
This is close to being satisfactory, but I'd like $y$'s type to be a function, and to have the variable
dependency in the argument. I don't think this is strictly necessary, but it makes things clearer.
I can represent the twelf code
\begin{verbatim}
o : type.
a : o -> type.
m : {x: o} a x.
w : {x : o} {y : a x -> o} {z : a (y (m x))} type.
k : o.
h : {x : o} a x -> o.
v : w k (h k) (m (h k (m k))).
\end{verbatim}
by
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
$o : \rtype$ & \texttt{type : o .}\\
$a : o \to \rtype$ & \texttt{o $\to$ type : a .}\\
$m : \{x : o\} \, a\ x$ &\texttt{o : x $\to$ x a : m . } \\
$w : \{x : o\} $&\texttt{o : x $\to$ }\\
$\ \,\,\quad \{y : a\ x \to o\}$ &\texttt{\ \ ( x a $\to$ o ) : y $\to$}\\
$\ \,\,\quad \{z : a\ (y\ (m\ x))\} \, \rtype$&\texttt{\ \ x m y a : z $\to$ type : w . } \\
$k : o$ & \texttt{o : k .}\\
$h : \{x : o\}\, a\ x \to o$ & \texttt{o : x $\to$ x a $\to$ o : h .}\\
$v : w\ k\ (h\ k)\ (m\ (h\ k\ (m\ k)))$& \texttt{k m k h m k h k w : v .}\\
\hline
\end{tabular}\]
}
so that should be a good exercise for the typechecker.

\subsection{Parenthesization}
Ultimately I think I'd like to have the canonical way that the user enters the signature to have
as few parentheses as possible, but for implementation clarity, I'm trying to work out if there's a viable
notion of `maximal' parenthesization. I think any type that ends up as a target for \texttt{.} or
$\to$ should be parenthesized, which would turn the above example into
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
$o : \rtype$ & \texttt{( type ) : o .}\\
$a : o \to \rtype$ & \texttt{( ( o ) $\to$ type ) : a .}\\
$m : \{x : o\} \, a\ x$ &\texttt{( ( o ) : x $\to$ x a ) : m . } \\
$w : \{x : o\} $&\texttt{( ( o ) : x $\to$ }\\
$\ \,\,\quad \{y : a\ x \to o\}$ &\texttt{\ \ ( ( x a ) $\to$ o ) : y $\to$}\\
$\ \,\,\quad \{z : a\ (y\ (m\ x))\} \, \rtype$&\texttt{\ \ ( x m y a ) : z $\to$ type ) : w . } \\
$k : o$ & \texttt{( o ) : k .}\\
$h : \{x : o\}\, a\ x \to o$ & \texttt{( ( o ) : x $\to$ ( x a ) $\to$ o ) : h .}\\
$v : w\ k\ (h\ k)\ (m\ (h\ k\ (m\ k)))$& \texttt{( k m k h m k h k w ) : v .}\\
\hline
\end{tabular}\]
}

In some sense \texttt{.} is doing the same job as $\to$, so I might even write this as
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
$o : \rtype$ & \texttt{( type ) : o $\to$}\\
$a : o \to \rtype$ & \texttt{( ( o ) $\to$ type ) : a $\to$}\\
$m : \{x : o\} \, a\ x$ &\texttt{( ( o ) : x $\to$ x a ) : m $\to$ } \\
$w : \{x : o\} $&\texttt{( ( o ) : x $\to$ }\\
$\ \,\,\quad \{y : a\ x \to o\}$ &\texttt{\ \ ( ( x a ) $\to$ o ) : y $\to$}\\
$\ \,\,\quad \{z : a\ (y\ (m\ x))\} \, \rtype$&\texttt{\ \ ( x m y a ) : z $\to$ type ) : w $\to$ } \\
$k : o$ & \texttt{( o ) : k $\to$}\\
$h : \{x : o\}\, a\ x \to o$ & \texttt{( ( o ) : x $\to$ ( x a ) $\to$ o ) : h $\to$}\\
$v : w\ k\ (h\ k)\ (m\ (h\ k\ (m\ k)))$& \texttt{( k m k h m k h k w ) : v $\to$}\\
\hline
\end{tabular}\]
}
The setting of the current name could be commuted with the \texttt{)}, to give
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
$o : \rtype$ & \texttt{( type : o ) $\to$}\\
$a : o \to \rtype$ & \texttt{( ( o ) $\to$ type : a ) $\to$}\\
$m : \{x : o\} \, a\ x$ &\texttt{( ( o : x ) $\to$ x a : m ) $\to$ } \\
$w : \{x : o\} $&\texttt{( ( o : x )  $\to$ }\\
$\ \,\,\quad \{y : a\ x \to o\}$ &\texttt{\ \ ( ( x a ) $\to$ o : y ) $\to$}\\
$\ \,\,\quad \{z : a\ (y\ (m\ x))\} \, \rtype$&\texttt{\ \ ( x m y a : z ) $\to$ type : w ) $\to$ } \\
$k : o$ & \texttt{( o : k ) $\to$}\\
$h : \{x : o\}\, a\ x \to o$ & \texttt{( ( o : x ) $\to$ ( x a ) $\to$ o : h ) $\to$}\\
$v : w\ k\ (h\ k)\ (m\ (h\ k\ (m\ k)))$& \texttt{( k m k h m k h k w : v ) $\to$}\\
\hline
\end{tabular}\]
}
And then maybe I could write \texttt{.} as an abbreviation for \texttt{) $\to$ (}:
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
 & \texttt{( }\\
$o : \rtype$ & \texttt{type : o .}\\
$a : o \to \rtype$ & \texttt{( o ) $\to$ type : a .}\\
$m : \{x : o\} \, a\ x$ &\texttt{( o : x ) $\to$ x a : m  } \\
$w : \{x : o\} $&\texttt{( o : x )  $\to$}\\
$\ \,\,\quad \{y : a\ x \to o\}$ &\texttt{\ \ ( ( x a ) $\to$ o : y ) $\to$ }\\
$\ \,\,\quad \{z : a\ (y\ (m\ x))\} \, \rtype$&\texttt{\ \ ( x m y a : z ) $\to$ type : w  . } \\
$k : o$ & \texttt{o : k .}\\
$h : \{x : o\}\, a\ x \to o$ & \texttt{( o : x ) $\to$ ( x a ) $\to$ o : h .}\\
$v : w\ k\ (h\ k)\ (m\ (h\ k\ (m\ k)))$& \texttt{k m k h m k h k w : v .}\\
\hline
\end{tabular}\]
}

But this feels genuinely different from my ``low-parenthesis''
notation in that I explicitly am signalling more information about
nested arrows. Maybe that's the mistake I've been making this whole time.

\subsection{$\beta$-reduction example}
What's an example where I really have to carry out an interesting $\beta$-reduction during typechecking?
The twelf
\begin{verbatim}
o : type.
k : o.
k2 : o.
a : o -> type.
m : {x : o} a x.
b : o -> o -> o.
c : {f : o -> o} {x : o} a (f (f x)) -> type.
d : c ([x] b x k2) k (m (b (b k k2) k2)).
\end{verbatim}
Could be represented as
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
$o : \rtype$ & \texttt{type : o .}\\
$k : o$ & \texttt{o : k .}\\
$k2 : o$ & \texttt{o : k2 .}\\
$a : o \to \rtype$ & \texttt{( o ) $\to$ type : a .}\\
$m : \{x : o\} \, a\ x$ &\texttt{( o : x ) $\to$ x a : m  } \\
$b : o \to o \to o$ & \texttt{( o ) $\to$ ( o ) $\to$ o : b .}\\
$c : \{f : o \to o\} $&\texttt{( ( o ) $\to$ o : f ) $\to$}\\
$\quad\ \,\{ x : o\}\, $&\texttt{\ \ ( o : x ) $\to$}\\
$\quad\ \,a\  (f\ (f\ x)) \to \rtype$&\texttt{\ \ ( x f f a ) $\to$ type : c .}\\
$d : c\ (\lambda t . b\ t\ k2)\ k$&\texttt{k2 k2 k b b m k }\\
$\quad\ \, (m\ (b\ (b\ k\ k2)\ k2)$&\texttt{\ \ [ ( o : t ) $\to$ k2 t b ] c : d .}\\
\hline
\end{tabular}\]
}
This emphasizes that to use the variable $f$ is not just to copy the
value of $f$ but to {\em run the program of $f$}. When we finally run $c$
after building up the stack in the definition of $d$, here's what happens:
\begin{itemize}
\item we grab and check that the function \texttt{[ ( o : t ) $\to$ k2 t b ]} has the right type $o \to o$,
which it does, and name it $f$ in the local substitution.
\item we grab and check the expression \texttt{k} has the right type $o$, which it does, and name it $x$.
\item we next want to grab and check the expression \texttt{k2 k2 k b b m} at a type, but finding out
what type takes some computation, so we start running the program \texttt{x f f a}
\begin{itemize}
\item we run the relatively trivial `program' $x$, which pushes \texttt{k}.
\item we run the program $f$, which pops an argument, names it $t$, and runs
\texttt{k2 t b}, which leaves us with the term \texttt{k2 k b}.
\item we run $f$ again, which pops an argument, names it $t$, and runs
\texttt{k2 t b}, which leaves us with the term \texttt{k2 k2 k b b}.
\end{itemize}
\item This is the type of the term \texttt{k2 k2 k b b m} that was sitting on the stack already.
\end{itemize}

\subsection{Variable Capture Example}
What's an example that would show if I was doing something wrong with using named variables and allowing
variable capture? In the twelf code
\begin{verbatim}
o : type.
p : type.
a : p -> o.
d : (o -> o) -> type.
b : o -> o -> o.
c : {y : o} d ([x] b y x) -> type.
q : {f : o -> o} d ([y] f y).
r : {x : p} c (a x) (q ([y] b (a x) y)).
\end{verbatim}
during typechecking of $r$, if we naively substituted $a\ x$ for $y$ in the rest of the type
$c$, we'd get $d\ (\lambda x . b\ (a\ x)\ x)$, which is not even type correct.
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
$o : \rtype$ & \texttt{type : o .}\\
$p : \rtype$ & \texttt{type : p .}\\
$a : o \to \rtype$ & \texttt{( o ) $\to$ type : a .}\\
$d : (o \to o) \to \rtype$ & \texttt{( ( o ) $\to$ o ) $\to$ type : d .}\\
$b : o \to o \to o$ & \texttt{( o ) $\to$ ( o ) $\to$ o : b .}\\
$c : \{ y : o\}\, d\ (\lambda x . b\ y\ x) \to \rtype$&\texttt{( o : y ) $\to$}\\
&\texttt{( [ ( o : x ) $\to$ x y b ] d ) $\to$ }\\
&\texttt{type : c .}\\
$q : \{ f : o \to o\}\, d\ (\lambda y . f\ y) $&\texttt{( ( o ) $\to$ o : f ) $\to$}\\
&\texttt{[ ( o : y ) $\to$ y f ] d : q .}\\
$r : \{ x : p\}\, c\ (a\ x)\ (q\ (\lambda y . b\ (a\ x)\ y))$&\texttt{( p : x ) $\to$}\\
&\texttt{\ \ [ ( o : y ) $\to$ y x a b ] q}\\
&\texttt{\ \ x a c}\\
&\texttt{: r .}\\
\hline
\end{tabular}\]
}
\subsection{Arrowless syntax}
I notice now $\to$ always comes after \texttt{)}, and I could make parens special one-character
tokens, so perhaps I might as well write things like:
{\renewcommand{\arraystretch}{1.2}
\[\begin{tabular}{l|l}
\hline
$o : \rtype$ & \texttt{(type : o)}\\
$a : o \to \rtype$ & \texttt{((o) type : a)}\\
$m : \{x : o\} \, a\ x$ &\texttt{((o : x) x a : m) } \\
$w : \{x : o\} $&\texttt{((o : x)  }\\
$\ \,\,\quad \{y : a\ x \to o\}$ &\texttt{\ \ ((x a) o : y)}\\
$\ \,\,\quad \{z : a\ (y\ (m\ x))\} \, \rtype$&\texttt{\ \ (x m y a : z) type : w) } \\
$k : o$ & \texttt{(o : k)}\\
$h : \{x : o\}\, a\ x \to o$ & \texttt{((o : x) (x a) o : h)}\\
$v : w\ k\ (h\ k)\ (m\ (h\ k\ (m\ k)))$& \texttt{(k m k h m k h k w : v)}\\
\hline
\end{tabular}\]
}

\end{document}
